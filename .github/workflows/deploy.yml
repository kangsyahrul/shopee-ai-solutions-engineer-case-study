name: Deploy Streamlit App to AWS ECS

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: ap-southeast-3
  ECR_REPOSITORY: shopee-ai-solutions-engineer-case-study-syahrul
  STACK_NAME: shopee-streamlit-app

jobs:
  check-changes:
    runs-on: ubuntu-latest
    outputs:
      docs-only: ${{ steps.check.outputs.docs-only }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Check if only docs changed
      id: check
      run: |
        # Get the list of changed files
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          # For PR, compare with base branch
          CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }}..${{ github.sha }})
        else
          # For push, compare with previous commit
          CHANGED_FILES=$(git diff --name-only HEAD~1..HEAD)
        fi
        
        echo "Changed files:"
        echo "$CHANGED_FILES"
        
        # Check if all changed files are documentation files
        DOCS_ONLY=true
        while IFS= read -r file; do
          if [[ -n "$file" && ! "$file" =~ ^(README\.md|.*\.md|docs/.*|DEPLOYMENT\.md|LICENSE.*|\.gitignore|.*\.txt|.*\.rst)$ ]]; then
            DOCS_ONLY=false
            break
          fi
        done <<< "$CHANGED_FILES"
        
        echo "docs-only=$DOCS_ONLY" >> $GITHUB_OUTPUT
        echo "Documentation only changes: $DOCS_ONLY"

  docs-only-info:
    needs: check-changes
    runs-on: ubuntu-latest
    if: needs.check-changes.outputs.docs-only == 'true'
    steps:
    - name: Documentation changes only
      run: |
        echo "ðŸ” Only documentation files were changed."
        echo "ðŸ“ Skipping build, test, and deployment pipeline."
        echo "âœ… No further action needed for documentation updates."

  test:
    needs: check-changes
    runs-on: ubuntu-latest
    if: needs.check-changes.outputs.docs-only != 'true'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'

    - name: Install uv
      uses: astral-sh/setup-uv@v3

    - name: Install dependencies
      run: |
        uv pip install --system -r pyproject.toml

    - name: Create test .env file
      run: |
        cat > .env << EOF
        # Test Environment Variables
        OPENAI_API_KEY=test-key-for-testing
        QDRANT_HOST=localhost
        QDRANT_PORT=6333
        QDRANT_API_KEY=""
        EOF

    - name: Run tests
      run: |
        # pytest tests/ -v --cov=src --cov-report=xml
        echo "Skip tests for now"

    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella

  build-and-push:
    needs: [check-changes, test]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && needs.check-changes.outputs.docs-only != 'true'
    outputs:
      image: ${{ steps.build-image.outputs.image }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Create ECR repository if it doesn't exist
      run: |
        aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region $AWS_REGION ||
        aws ecr create-repository --repository-name $ECR_REPOSITORY --region $AWS_REGION

    - name: Create .env file for production
      run: |
        cat > .env << EOF
        # Production Environment Variables
        OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
        QDRANT_HOST=${{ secrets.QDRANT_HOST || 'localhost' }}
        QDRANT_PORT=${{ secrets.QDRANT_PORT || '6333' }}
        QDRANT_API_KEY=${{ secrets.QDRANT_API_KEY }}
        
        # Streamlit Configuration
        STREAMLIT_SERVER_PORT=8501
        STREAMLIT_SERVER_ADDRESS=0.0.0.0
        STREAMLIT_SERVER_HEADLESS=true
        STREAMLIT_BROWSER_GATHER_USAGE_STATS=false
        EOF

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build a docker container and push it to ECR
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

  deploy-infrastructure:
    needs: [check-changes, build-and-push]
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: github.ref == 'refs/heads/main' && needs.check-changes.outputs.docs-only != 'true'
    outputs:
      cluster-name: ${{ steps.deploy-stack.outputs.cluster-name }}
      service-name: ${{ steps.deploy-stack.outputs.service-name }}
      load-balancer-dns: ${{ steps.deploy-stack.outputs.load-balancer-dns }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Check stack status
      run: |
        STACK_STATUS=$(aws cloudformation describe-stacks --stack-name $STACK_NAME --region $AWS_REGION --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "NOT_FOUND")
        echo "Current stack status: $STACK_STATUS"
        
        # If stack is already in a complete state, we can proceed
        if [[ "$STACK_STATUS" == "CREATE_COMPLETE" || "$STACK_STATUS" == "UPDATE_COMPLETE" ]]; then
          echo "Stack is already in a complete state, proceeding..."
        elif [[ "$STACK_STATUS" == *"IN_PROGRESS" ]]; then
          echo "Stack operation is in progress, will wait for completion..."
        fi

    - name: Deploy CloudFormation stack
      id: deploy-stack
      run: |
        # Check if stack exists
        if aws cloudformation describe-stacks --stack-name $STACK_NAME --region $AWS_REGION 2>/dev/null; then
          echo "Stack exists, updating..."
          aws cloudformation update-stack \
            --stack-name $STACK_NAME \
            --template-body file://cloudformation/stack.yaml \
            --parameters \
              ParameterKey=DockerImage,ParameterValue=${{ needs.build-and-push.outputs.image }} \
              ParameterKey=OpenAIApiKey,ParameterValue=${{ secrets.OPENAI_API_KEY }} \
              ParameterKey=QdrantHost,ParameterValue=${{ secrets.QDRANT_HOST || 'localhost' }} \
              ParameterKey=QdrantPort,ParameterValue=${{ secrets.QDRANT_PORT || '6333' }} \
              ParameterKey=QdrantApiKey,ParameterValue=${{ secrets.QDRANT_API_KEY || '' }} \
              ParameterKey=TaskCpu,ParameterValue=${{ secrets.ECS_TASK_CPU || '512' }} \
              ParameterKey=TaskMemory,ParameterValue=${{ secrets.ECS_TASK_MEMORY || '1024' }} \
              ParameterKey=DesiredCount,ParameterValue=${{ secrets.ECS_DESIRED_COUNT || '1' }} \
            --capabilities CAPABILITY_IAM \
            --region $AWS_REGION || echo "No updates required"
        else
          echo "Stack doesn't exist, creating..."
          aws cloudformation create-stack \
            --stack-name $STACK_NAME \
            --template-body file://cloudformation/stack.yaml \
            --parameters \
              ParameterKey=DockerImage,ParameterValue=${{ needs.build-and-push.outputs.image }} \
              ParameterKey=OpenAIApiKey,ParameterValue=${{ secrets.OPENAI_API_KEY }} \
              ParameterKey=QdrantHost,ParameterValue=${{ secrets.QDRANT_HOST || 'localhost' }} \
              ParameterKey=QdrantPort,ParameterValue=${{ secrets.QDRANT_PORT || '6333' }} \
              ParameterKey=QdrantApiKey,ParameterValue=${{ secrets.QDRANT_API_KEY || '' }} \
              ParameterKey=TaskCpu,ParameterValue=${{ secrets.ECS_TASK_CPU || '512' }} \
              ParameterKey=TaskMemory,ParameterValue=${{ secrets.ECS_TASK_MEMORY || '1024' }} \
              ParameterKey=DesiredCount,ParameterValue=${{ secrets.ECS_DESIRED_COUNT || '1' }} \
            --capabilities CAPABILITY_IAM \
            --region $AWS_REGION
        fi

        echo "Waiting for stack operation to complete..."
        
        # Check stack status and wait accordingly
        STACK_STATUS=$(aws cloudformation describe-stacks --stack-name $STACK_NAME --region $AWS_REGION --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "NOT_FOUND")
        
        if [[ "$STACK_STATUS" == *"CREATE"* ]]; then
          echo "Stack is being created, waiting for CREATE_COMPLETE..."
          aws cloudformation wait stack-create-complete --stack-name $STACK_NAME --region $AWS_REGION
        elif [[ "$STACK_STATUS" == *"UPDATE"* ]]; then
          echo "Stack is being updated, waiting for UPDATE_COMPLETE..."
          aws cloudformation wait stack-update-complete --stack-name $STACK_NAME --region $AWS_REGION
        else
          echo "Stack status: $STACK_STATUS"
          # Generic wait with timeout
          for i in {1..60}; do
            CURRENT_STATUS=$(aws cloudformation describe-stacks --stack-name $STACK_NAME --region $AWS_REGION --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "NOT_FOUND")
            echo "Current stack status: $CURRENT_STATUS"
            
            if [[ "$CURRENT_STATUS" == *"COMPLETE" && "$CURRENT_STATUS" != *"DELETE_COMPLETE" ]]; then
              echo "Stack operation completed successfully!"
              break
            elif [[ "$CURRENT_STATUS" == *"FAILED" || "$CURRENT_STATUS" == *"ROLLBACK"* ]]; then
              echo "Stack operation failed with status: $CURRENT_STATUS"
              exit 1
            fi
            
            sleep 30
          done
        fi

        # Get outputs
        CLUSTER_NAME=$(aws cloudformation describe-stacks \
          --stack-name $STACK_NAME \
          --region $AWS_REGION \
          --query 'Stacks[0].Outputs[?OutputKey==`ECSClusterName`].OutputValue' \
          --output text)
        
        SERVICE_NAME=$(aws cloudformation describe-stacks \
          --stack-name $STACK_NAME \
          --region $AWS_REGION \
          --query 'Stacks[0].Outputs[?OutputKey==`ECSServiceName`].OutputValue' \
          --output text)

        LOAD_BALANCER_DNS=$(aws cloudformation describe-stacks \
          --stack-name $STACK_NAME \
          --region $AWS_REGION \
          --query 'Stacks[0].Outputs[?OutputKey==`LoadBalancerDNS`].OutputValue' \
          --output text)

        echo "cluster-name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
        echo "service-name=$SERVICE_NAME" >> $GITHUB_OUTPUT
        echo "load-balancer-dns=$LOAD_BALANCER_DNS" >> $GITHUB_OUTPUT

  deploy-application:
    needs: [check-changes, build-and-push, deploy-infrastructure]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && needs.check-changes.outputs.docs-only != 'true'
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Update ECS Service
      run: |
        echo "Updating ECS service to use new image..."
        
        # Get current task definition
        TASK_DEFINITION_ARN=$(aws ecs describe-services \
          --cluster ${{ needs.deploy-infrastructure.outputs.cluster-name }} \
          --services ${{ needs.deploy-infrastructure.outputs.service-name }} \
          --region $AWS_REGION \
          --query 'services[0].taskDefinition' \
          --output text)
        
        echo "Current task definition: $TASK_DEFINITION_ARN"
        
        # Get the task definition details
        aws ecs describe-task-definition \
          --task-definition $TASK_DEFINITION_ARN \
          --region $AWS_REGION \
          --query 'taskDefinition' > task-def.json
        
        # Update the image in the task definition
        NEW_IMAGE="${{ needs.build-and-push.outputs.image }}"
        jq --arg IMAGE "$NEW_IMAGE" '.containerDefinitions[0].image = $IMAGE' task-def.json > updated-task-def.json
        
        # Remove fields not needed for registration
        jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)' updated-task-def.json > final-task-def.json

        # Register new task definition
        NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
          --cli-input-json file://final-task-def.json \
          --region $AWS_REGION \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        
        echo "New task definition: $NEW_TASK_DEF_ARN"
        
        # Update the service to use new task definition
        aws ecs update-service \
          --cluster ${{ needs.deploy-infrastructure.outputs.cluster-name }} \
          --service ${{ needs.deploy-infrastructure.outputs.service-name }} \
          --task-definition $NEW_TASK_DEF_ARN \
          --region $AWS_REGION

    - name: Wait for deployment to complete
      run: |
        echo "Waiting for ECS service to stabilize..."
        aws ecs wait services-stable \
          --cluster ${{ needs.deploy-infrastructure.outputs.cluster-name }} \
          --services ${{ needs.deploy-infrastructure.outputs.service-name }} \
          --region $AWS_REGION

    - name: Display deployment info
      run: |
        echo "ðŸŽ‰ Deployment completed successfully!"
        echo "ðŸŒ Application URL: http://${{ needs.deploy-infrastructure.outputs.load-balancer-dns }}"
        echo "ï¿½ ECS Cluster: ${{ needs.deploy-infrastructure.outputs.cluster-name }}"
        echo "ðŸ“Š ECS Service: ${{ needs.deploy-infrastructure.outputs.service-name }}"
        
        # Get service status
        aws ecs describe-services \
          --cluster ${{ needs.deploy-infrastructure.outputs.cluster-name }} \
          --services ${{ needs.deploy-infrastructure.outputs.service-name }} \
          --region $AWS_REGION \
          --query 'services[0].{RunningCount:runningCount,DesiredCount:desiredCount,Status:status}' \
          --output table

  cleanup:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'closed'
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Delete CloudFormation stack for PR
      run: |
        PR_STACK_NAME="${STACK_NAME}-pr-${{ github.event.number }}"
        if aws cloudformation describe-stacks --stack-name $PR_STACK_NAME --region $AWS_REGION 2>/dev/null; then
          echo "Deleting stack $PR_STACK_NAME"
          aws cloudformation delete-stack --stack-name $PR_STACK_NAME --region $AWS_REGION
          aws cloudformation wait stack-delete-complete --stack-name $PR_STACK_NAME --region $AWS_REGION
        fi